\section{IOS}
Meine bisherigen Erfahrungen mit der Entwicklung mobiler Applikationen beschränken sich ausschließlich auf Android, daher bin ich als vollkommener Neuling in iOS eingestiegen. Sämtliche Bewertungen und Ansichten kommen deshalb aus Sicht eines iOS-Neueinsteigers und decken lediglich grundlegende iOS Funktionen und Techniken ab.
\subsection{IDE}
Xcode als grundlegende IDE bietet umfangreiche Tools und Möglichkeiten, welche Entwicklung, Refactoring und Testen vereinfachen. Leider werden einige dieser nützlichen Funktionalitäten noch nicht für Swift angeboten, beispielsweise kann Code Refactoring nur für Objective-C Code durchgeführt werden. Ein weiterer negativer Punkt bei Xcode betrifft die fehlenden Code-Formating-Templates. Code kann zwar formatiert werden, damit ein einheitliches Code Layout gewährleistet werden kann, allerdings besteht keine Möglich\-keit, das von XCode mitgelieferte Template, welches auch für Autovervollständigung genutzt wird, zu ändern. Hinsichtlich UI kann XCode mit einem sehr fortschrittlichen und umfangreichen graphischen Editor punkten. Alternative IDEs wie Jetbrains AppCode hinken hier deutlich hinterher, bieten aber deutlich besseren Support für Refactoring oder Code-Formatting. Da im Allgemeinen noch Nachholbedarf im Bereich IDE liegt, vergebe ich 2 von 3 möglichen Punkten.
\subsection{Language}
Swift entpuppt sich als angenehme Programmiersprache und verursacht bisher wenige Probleme. Da Swift erst 2014 erschienen und damit relativ jung ist, hält sich der Online-Support in Grenzen. Nichtsdestotrotz stellt Swift keine große Hürde dar und kann auch problemlos mit Objective-C kombiniert werden, weshalb eine Bewertung mit 3 von 3 Punkten angemessen ist.
\vfill
\subsection{Support}
Apple bietet auf der offiziellen Entwickler-Webpage etliche Tutorials, Videos und Testprojekte an. Aber auch im Internet findet sich eine große Community mit zahlreichen Beispielen und Lösungen zu vielen Problemen. Da Swift relativ neu ist dominiert der Objective-C Support im Allgemeinen, dennoch können viele Objective-C Lösungen auf Swift angewendet werden, weil die meisten Aufrufe beider Sprachen identisch sind. Meine bisherige Erfahrung zeigt, dass der iOS Support sehr umfangreich ist und anderen Frameworks in nichts nachsteht. Leider werden noch viele Codebeispiele in Objective-C geschrieben was den Umgang etwas erschweren kann wenn als Programmiersprache Swift genutzt wird. Da im Großen und Ganzen der Support sehr weitreichend ist, vergebe ich 3 von 3 möglichen Punkten.
\subsection{Geolocation}
Im Bezug auf Geolocation bietet iOS umfangreiche Unterstützung, weshalb sich eine Umsetzung als relativ unkompliziert gestaltet. Durch wenige Zeilen Code kann die aktuelle Position über GPS oder WiFi ermittelt und weiterverarbeitet werden. Um auf Geolocation Funktionen zuzugreifen muss die Erlaubnis des Nutzers erfragt werden, anschließend kann uneingeschränkt auf die Location zugegriffen werden. Die Informationen der erhaltenen Position reichen von Koordinaten bis hin zu konkreten, ortsbezogenen Details wie Land, Staat oder Ort. Letzteres erfordert eine Verbindung zum Apple Server, an welchen die Koordinaten gesendet werden. Aufgrund der positiven Erfahrung vergebe ich im Bereich Geolocation 3 von 3 Punkte.
\subsection{Notifications}
iOS etabliert ein ausgeprägtes Notification-System, weshalb auch entsprechende Funktionalitäten angeboten werden. Die Umsetzung gestaltet sich hier ebenfalls als unproblematisch und schnell, wobei es in Bezug auf lokale Notifications Grenzen gibt. Wird eine lokale Notification erstellt, feuert diese zu einem angegebenen Zeitpunkt, unabhängig davon ob die App aktiv, inaktiv oder geschlossen ist. Der Zeitpunkt lässt sich frei definieren und kann sich periodisch wiederholen, wobei lediglich vordefinierte Perioden (jede Minute, täglich, wöchentlich, monatlich, jährlich) ausgewählt werden können. Bei Eintritt der Notification kann über Interaktion mit dem Nutzer eigene Funktionalität ausgeführt werden, wie beispielsweise das Starten der App. Eine automatische Ausführung von Code oder das Aufwecken der App bei Ereigniseintritt ist bei lokalen Notifications nicht möglich und erfordert immer eine Nutzerinteraktion.
Dieses Verhalten liegt unter anderem daran, dass iOS Hintergrundanwendungen lediglich auf spezielle Funktionalitäten beschränkt, Apps die nicht diesen Anforderungen entsprechen werden nach ca. drei Minuten im Hintergrund still gelegt.
Bei Push Notifications über einen Server ändert sich dieses Verhalten, leider beschränkt sich mein Wissen ausschließlich auf lokale Notifications, weshalb ich darüber keine Auskunft geben kann. Aus genannten Gründen vergebe ich deshalb 2 von 3 möglichen Punkten.
\subsection{Email}
Das Versenden von Emails läuft bei iOS über den internen Mail Service. Soll eine neue Email über die eigenen App versendet werden kann ein neuer Controller gestartet werden, der die vollständige Funktionalität zum Versenden der Mail übernimmt. Zuvor können noch Empfänger, Titel, Texte und Anhänge jeglicher Art gesetzt werden. Damit eine Email versendet werden kann, muss bereits ein Account auf dem Gerät existieren. Dieser kann durch die offizielle Mail App erstellt und verwaltet werden. Die Implementierung beschränkt sich hier ebenfalls auf wenige Zeilen Code und stellt keine Hürden in den Weg, daher vergebe ich 3 von 3 möglichen Punkten.
\subsection{Persistence}
SQLite bietet sich als lokale Datenbank auf dem Gerät an. iOS stellt eine vollständige Objective-C API zur Verfügung, die eine problemlose Verwendung von SQLite ermöglicht. Allerdings fehlt bisher eine Unterstützung von Swift, weshalb hier auf Drittbibliotheken zurückgegriffen werden muss, die als Wrapper der Objective-C API fungieren. Die Handhabung und Vielfalt von SQLite ermöglicht eine unproblematische Erzeugung von performanten Datenbanken die lokal auf dem mobilen Gerät liegen und mit Hilfe der iOS API problemlos genutzt werden kann. Aufgrund des fehlenden Swift Supports aber der sonst reibungslosen Integration vergebe ich im Bereich Persistence 3 von 3 Punkten.
\subsection{Design}
Hinsichtlich Design und UI-Entwicklung kann iOS voll über\-zeugen und steht hier klar auf Vorreiterposition. Werden iOS Styleguides und Vorgaben eingehalten, können in kurzer Zeit funktionsfähige und optisch ansprechende Apps entstehen, was definitiv für iOS spricht. Durch einfache Klicks können animierte Transitionen mit Navigation zwischen verschiedenen Screens erzeugt werden, ohne dabei überhaupt Code anfassen zu müssen. Auch viele vorgefertigte UI Elemente wie Tab-Leisten oder Navigationsbars können problemlos umgesetzt werden. Problematisch hingegen könnte die individuelle Anpassung einer Applikation an ein selbst entwickeltes Design werden. Meine bisherigen Erfahrungen haben gezeigt, dass ein tieferer Eingriff in das Framework oft komplizierter und langwieriger sein kann als die gewohnten, intuitiven Funktionalitäten. Im Vergleich bietet andere Frameworks hier deutlich mehr Widgets und Anpassungsmöglichkeiten als iOS. Dennoch konnten bisher alle Funktionalitäten in passender Zeit umgesetzt und individuelle Anpassungen größtenteils vermieden werden. Natürlich muss sich immer Frage gestellt werden, ob ein individuelles Design, welches vollständig von Apple abweicht, sinnvoll ist. Nicht zuletzt der User hat die Erwartung, dass eine App das gewohnte Umfeld einer iOS Applikation widerspiegelt und nicht vollständig vom iOS-Idealbild abweicht. Da dennoch iOS hinsichtlich Design in vielen Punkten vorne liegt vergebe ich 3 von 3 Punkten.
\subsection{Testing}
Im Bereich des Testens werden von Seiten des Frameworks nützliche Tools angeboten. Jedes iOS Projekt besitzt von Haus aus ein Testordner, der mit Unit-Tests angereichert werden kann. Bei Ausführung werden diese Tests auf dem Gerät oder Simulator durchgeführt und validiert. An\-schlie\-ßende Ergebnisse können in der IDE verfolgt werden. Für Benutzeroberflächen bietet Apple ein Framework zur Automatisierung an, womit UI-Interaktionen simuliert und getestet werden können. Allerdings fehlt hier die Projektintegration, weshalb vollautomatische Frameworks zum Testen von UI wie Appium an dieser Stelle sinnvoller wären. Im Allgemeinen gestaltet sich das Testen der App daher als aufwändiger, wenn in allen Bereichen, einschließlich Nutzeroberfläche, getestet werden soll. Nichtsdestotrotz werden die grundlegenden Anforderungen an Testing erfüllt, weshalb ich 2 von 3 Punkten vergebe.
